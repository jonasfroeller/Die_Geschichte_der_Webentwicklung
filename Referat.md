# Die Geschichte der Webentwicklung

<!--
# Referat für die Seele

> [Liste](https://docs.google.com/spreadsheets/d/1cJT-7qjM3y-hm-5fVn0I9s6b5iVMWRCnToSE91Wp0Vk/edit?gid=0#gid=0)

**Anforderungen:**

1. 10-12min
2. mindestens 3 Quellen
3. Handout

**2 Wichtige Komponenten:**

- Referat Halten können
- Kritikfähigkeit

Zusammengefasst: 10-12 min PRO PERSON; mind 3 Quellen + Handout
(vorher am 27.11.2024, jetzt am 25.11.2024)
-->

## Geschichte

### Warum?

Die Webentwicklung entstand aus der Notwendigkeit, Informationen im World Wide Web zu präsentieren und zu verbreiten. Websites wurden entwickelt, um Inhalte im Internet zugänglich zu machen und eine Plattform für Kommunikation und Informationsaustausch zu schaffen.

### Ursprung der Webentwicklung

#### Erfindung des World Wide Web

Tim Berners-Lee, ein Mitarbeiter des Schweizer Physik-Labors CERN, erfand das World Wide Web im Jahr 1989[2][3]. Diese Erfindung legte den Grundstein für die moderne Webentwicklung und revolutionierte die Art und Weise, wie wir Informationen teilen und abrufen.

#### Frühe Entwicklungen

In den 1990er Jahren begannen Technik-Enthusiasten, eigene Homepages zu programmieren, die hauptsächlich aus Blogs oder einfachen HTML-Tabellen bestanden[2]. Mit der Zeit wurden die Inhalte dynamischer, und die Webentwicklung entwickelte sich von einer Nische zu einem wichtigen Bereich der Informationstechnologie.

https://motherfuckingwebsite.com  
https://stallman.org/stallman-computing.html  
https://www.arngren.net

#### Gründe für die Entstehung von Websites

1. **Informationsverbreitung**: Websites ermöglichen es Unternehmen und Einzelpersonen, Informationen einem breiten Publikum zugänglich zu machen.

2. **Kommunikation**: Das Web bietet eine Plattform für den Austausch von Ideen und die Vernetzung von Menschen weltweit.

3. **Geschäftliche Präsenz**: Unternehmen nutzen Websites, um ihre Produkte und Dienstleistungen zu präsentieren und mit Kunden in Kontakt zu treten[3].

4. **Technologischer Fortschritt**: Die zunehmende Komplexität von Software-Anwendungen erforderte spezialisierte Entwickler für die Erstellung von Webanwendungen[3].

#### Heute

Die Webentwicklung hat sich seitdem kontinuierlich weiterentwickelt, von statischen HTML-Seiten in den 1990er Jahren bis hin zu den heutigen dynamischen und interaktiven Webanwendungen, die den hochtechnologischen Ansprüchen unserer Zeit gerecht werden[3].

https://aiden.mov

## Browser

### Was waren die ersten Browser?

#### Die ersten Webbrowser

Tim Berners-Lee entwickelte die ersten Webbrowser am CERN in der Schweiz. Es gab zwei bedeutende frühe Browser:

1. **WorldWideWeb (später Nexus)**

- Entwickelt 1990 auf einer NeXT-Workstation
- Nur auf NeXTStep-Betriebssystem lauffähig
- Konnte Grafiken nicht automatisch öffnen
- Erster Browser der Computergeschichte

2. **Line Mode Browser**

- Im November 1990 von Nicola Pellow entwickelt
- Minimalistischer Browser
- Konnte nur Text darstellen
- Lief auf "praktisch allen" Rechnern

##### Weitere frühe Browser

Nach diesen ersten Entwicklungen folgten:

- **Mosaic** (1993): Erster Browser mit grafischer Benutzeroberfläche
- **Netscape Navigator** (1994): Verbesserte Browserversion, die Mosaic schnell verdrängte
- **Cello** (1993): Entwickelt an der Cornell Law School für Windows

Diese Browser legten den Grundstein für die moderne Webentwicklung und internetbasierte Kommunikation.

### Das Browser Monopol - Chrome

Das US-Justizministerium hat am 21. November 2024 einen bedeutsamen Schritt gegen Googles Browser-Dominanz unternommen.

#### Kernpunkte des Chrome-Monopols

##### Marktdominanz

- Chrome hat weltweit einen Marktanteil von etwa zwei Dritteln
- In den USA beträgt der Marktanteil rund 60 Prozent
- In Deutschland liegt der Marktanteil bei etwa 45 Prozent

##### Rechtliche Herausforderungen

Das Justizministerium fordert:

- Verkauf des Chrome-Browsers
- Verbot von ausschließenden Verträgen mit Drittanbietern
- Keine Bevorzugung eigener Dienste
- Keine Zahlungen an andere Browser für Standardeinstellungen

##### Potenzielle Konsequenzen

- Geschätzter Verkaufswert von Chrome: 20 Milliarden Dollar
- Mögliches Verbot der Browsermarkt-Teilnahme für Google für 5 Jahre
- Endgültige Entscheidung wird im Spätsommer 2025 erwartet

#### Politische Unsicherheit

Die weitere Entwicklung bleibt unsicher, da Donald Trump im Januar 2025 Präsident wird und sich bereits skeptisch über eine Google-Zerschlagung geäußert hat.

## Suchmaschinen

### Die Pioniere der Suchmaschinen

Die Geschichte der Suchmaschinen begann 1990 mit **Archie**, der ersten Suchmaschine der Welt. Entwickelt an der McGill Universität in Montreal, war Archie ursprünglich darauf ausgelegt, FTP-Verzeichnisse zu durchsuchen, konnte aber keine Texte analysieren[1][2][4].

#### Frühe Entwicklungen

1. **Archie (1990)**: Erste Suchmaschine, durchsuchte Dateien und Ordner in FTP-Verzeichnissen[1][2]

2. **Gopher (1991)**: Ursprünglich für die Vernetzung von Informationen an der Universität von Minnesota entwickelt[2]

3. **Veronica (1991)**: Suchprogramm für Gopher mit fortschrittlichen Suchmöglichkeiten wie booleschen Operatoren[2]

#### Bedeutende Suchmaschinen der 1990er

- **Lycos (1994)**: Konnte Dokumente durchsuchen und Häufigkeit von Suchbegriffen ermitteln[2]

- **Yahoo! (1994)**: Begann als Sammlung von Favoriten-Links[2]

- **AltaVista**: Dominierte lange den Suchmaschinenmarkt mit dem leistungsstarken Roboter „Scooter"[2]

- **Google (1998)**: Trat später in den Markt ein, revolutionierte aber die Suche mit überlegener Relevanz und Geschwindigkeit[2]

## Der Wandel über die Jahre - Technologien kommen- und gehen

### Google's tote Software

#### Flash Player

https://killedbygoogle.com

##### Auswirkungen

- viele gute Spiele im Web funktionieren nicht mehr
  - nur mit Emulatoren, die RAM leaks haben, kann man diese noch vereinzelt spielen

## Framework Hölle

### React vs. Vue vs. Svelte

Die Diskussion über die Entwicklung von Webframeworks und die Rückkehr zu einfacheren Ansätzen wie Server-Side Rendering (SSR) und Technologien wie htmx ist aktuell und relevant. Hier sind einige wichtige Punkte dazu:

#### Die Geschichte der Frameworks

#### Erste Frameworks
- **JavaScript-Frameworks** haben ihre Wurzeln in den frühen 2000er Jahren, mit jQuery als einem der ersten und einflussreichsten Frameworks, das die DOM-Manipulation vereinfachte.
- Mit der Einführung von **AngularJS** (2010) begann eine neue Ära von Frameworks, die strukturierte Ansätze für die Entwicklung von Single Page Applications (SPAs) boten.

#### Der Aufstieg von React, Vue und Svelte
- **React** (2013): Entwickelt von Facebook, revolutionierte es die Art und Weise, wie Benutzeroberflächen durch Komponenten strukturiert werden.
- **Vue.js** (2014): Bietet eine flexible und leichtgewichtige Alternative zu React und Angular, die schnell an Popularität gewann.
- **Svelte** (2016): Ein innovatives Framework, das zur Build-Zeit kompiliert wird und keine Laufzeitbibliothek benötigt, was zu einer besseren Performance führt.

### Framework-Hölle
Die Vielzahl an verfügbaren JavaScript-Frameworks hat zu einer sogenannten "Framework-Hölle" geführt, in der Entwickler oft Schwierigkeiten haben, das richtige Werkzeug für ihre Projekte auszuwählen. Diese Hölle ist geprägt von:

- **Komplexität**: Jedes Framework hat seine eigenen Konzepte und Paradigmen.
- **Überladung**: Oft werden umfangreiche Bibliotheken benötigt, um einfache Aufgaben zu erledigen.
- **Wartbarkeit**: Der Wechsel zwischen Frameworks kann kostspielig und zeitaufwendig sein.

### Rückkehr zu den Wurzeln: SSR und htmx
In den letzten Jahren gibt es einen Trend zurück zu einfacheren Ansätzen:

#### Server-Side Rendering (SSR)
- SSR ermöglicht es, Seiten auf dem Server zu rendern, bevor sie an den Client gesendet werden. Dies verbessert die Ladezeiten und SEO.
- Beliebte SSR-Frameworks sind Next.js (für React) und Nuxt.js (für Vue).

#### HTMX
- htmx ist eine kleine JavaScript-Bibliothek, die es ermöglicht, HTML direkt vom Server zu laden und dynamisch in bestehende Seiten einzufügen.
- Es fördert einen einfacheren Ansatz zur Erstellung interaktiver Webanwendungen ohne umfangreiche Client-seitige Frameworks.

### Fazit
Die Entwicklung von Webtechnologien zeigt einen Zyklus von Komplexität hin zu Einfachheit. Während moderne Frameworks wie React, Vue und Svelte leistungsstarke Werkzeuge bieten, erkennen viele Entwickler den Wert einfacher Ansätze wie SSR und htmx. Diese Methoden ermöglichen es, robuste Anwendungen mit weniger Overhead zu erstellen und fördern eine bessere Benutzererfahrung.

https://krausest.github.io/js-framework-benchmark/2024/table_chrome_129.0.6668.58.html

## State of Frontend

https://tsh.io/state-of-frontend

## Neue Features: HTML5, CSS3, ES6 & neuer Wahnsinn

### Typescript

#### JavaScript

Der ursprüngliche Prototyp von JavaScript, genannt "Mocha", wurde tatsächlich in nur 10 Tagen von Brendan Eich im Mai 1995 entwickelt. Diese erste Version war jedoch nur ein minimaler Prototyp für eine interne Demonstration bei Netscape[1].

Die Entwicklung von JavaScript, wie wir es heute kennen, dauerte jedoch viel länger:

1. JavaScript 1.0 wurde im März 1996 öffentlich veröffentlicht, etwa 10 Monate nach dem ursprünglichen Prototyp[1].
2. Die erste "vollständige" Version wurde im August 1996 veröffentlicht, rund 15 Monate nach dem Prototyp[1].
3. Die Entwicklung ging weit über diese ersten Veröffentlichungen hinaus. Eich erinnert sich, dass sie im Herbst 1996 immer noch wesentliche Änderungen an JavaScript vornahmen[1].

Es ist wichtig zu beachten, dass Eich vor der Erstellung von JavaScript etwa zehn Jahre Erfahrung in der Sprachgestaltung und Compilerentwicklung hatte[1]. Darüber hinaus setzte sich die Entwicklung von JavaScripts Funktionen und APIs noch viele Jahre nach der ersten Veröffentlichung fort, mit wichtigen Meilensteinen wie:

- Die Standardisierung als ECMAScript im Jahr 1997
- Bedeutende Updates mit ECMAScript 3 im Jahr 1999
- Eine umfassende Überarbeitung mit ECMAScript 6 (ES2015) im Jahr 2015

Zusammengefasst lässt sich sagen, dass der ursprüngliche Prototyp nur 10 Tage in Anspruch nahm, die Entwicklung von JavaScript zu einer vollständig ausgeprägten Sprache jedoch ein fortlaufender Prozess war, der über viele Jahre andauerte[1][3].

#### Was ist TypeScript?

TypeScript ist eine Obermenge von JavaScript, die optionales statisches Typing und andere Funktionen hinzufügt, um die JavaScript-Entwicklung zu verbessern. Es wurde 2012 von Microsoft entwickelt, um einige der Einschränkungen von JavaScript zu beheben, insbesondere für groß angelegte Anwendungen.

Wichtige Aspekte von TypeScript sind:

- Statisches Typing: Ermöglicht es Entwicklern, Typannotationen für Variablen, Funktionen und andere Codeelemente hinzuzufügen
- Objektorientierte Programmierfunktionen: Unterstützt Klassen, Interfaces und Module
- Kompatibilität: Wird zu standardmäßigem JavaScript kompiliert, das in jeder Umgebung ausgeführt werden kann, die JS unterstützt

#### Warum TypeScript verwenden?

Es gibt mehrere überzeugende Gründe, TypeScript zu verwenden:

##### 1. Verbesserte Codequalität und Wartbarkeit

- Statisches Typing erkennt Fehler frühzeitig in der Entwicklung
- Selbstdokumentierender Code verbessert die Lesbarkeit und Verständlichkeit
- Erleichtertes Refactoring und bessere Navigation im Code

##### 2. Verbesserte Entwicklerproduktivität

- Umfangreiche IDE-Unterstützung mit intelligenter Code-Vervollständigung und Inline-Dokumentation
- Schnelleres Debuggen durch Fehlerprüfung zur Kompilierzeit
- Bessere Werkzeuge für große Codebasen

##### 3. Stärkere Teamzusammenarbeit

- Typdefinitionen dienen als klare Verträge zwischen verschiedenen Teilen des Codebestands
- Einfachere Einarbeitung neuer Teammitglieder
- Erzwingt konsistente Codierungsstandards

##### 4. Bessere Fehlererkennung

- Erkennt viele häufige Fehler zur Kompilierzeit anstatt zur Laufzeit
- Reduziert Fehler im Zusammenhang mit Typfehlern oder falschen Funktionsaufrufen

##### 5. Erweiterte JavaScript-Funktionen

- Zugriff auf die neuesten ECMAScript-Funktionen, selbst für ältere Laufzeitumgebungen
- Fügt nützliche Funktionen wie Interfaces und Enums hinzu

Indem TypeScript diese Problembereiche anspricht, hilft es Entwicklern, robustere und wartungsfreundlichere Anwendungen zu erstellen, besonders wenn Projekte an Größe und Komplexität zunehmen.

### Serverless

#### Serverless Architektur: Wichtige Herausforderungen

Serverless-Computing ist zwar innovativ, bringt jedoch erhebliche Nachteile mit sich, die es für viele Anwendungen problematisch machen können:

#### Wichtige Einschränkungen

1. **Leistungsprobleme**

- Unvorhersehbare Antwortzeiten
- "Cold Start"-Problem, das zu erheblicher Latenz führt
- Inkonsistente Ausführungsumgebungen
- Maximaler Funktionsausführungszeitraum von 15 Minuten

2. **Sicherheitsrisiken**

- Erhöhte Angriffsfläche aufgrund mehrerer Microservice-Endpunkte
- Multi-Tenant-Serverumgebungen schaffen potenzielle Sicherheitslücken für Datenlecks
- Eingeschränkte Sichtbarkeit und Kontrolle über die Infrastruktur

3. **Skalierbarkeitseinschränkungen**

- Keine wirklich "unendliche" Skalierung
- AWS Lambda begrenzt gleichzeitige Ausführungen (3000 initial, 500 zusätzliche pro Minute)
- Potenzielle Engpässe in nachgelagerten Systemen

4. **Komplexität bei der Fehlersuche**

- Fehlender direkter Serverzugriff
- Schwierigkeit, Fehler zu reproduzieren und nachzuvollziehen
- Eingeschränkte Überwachungsmöglichkeiten
- Verteiltes System erschwert die Fehlerbehebung

5. **Vendor-Lock-In**

- Hohe Abhängigkeit vom Ökosystem eines bestimmten Cloud-Anbieters
- Schwierige und teure Migration zwischen Plattformen
- Jeder Anbieter bietet einzigartige, nicht übertragbare Funktionen

#### Wann Serverless eine schlechte Wahl ist

- Anwendungen, die eine konsistente, vorhersehbare Leistung erfordern
- Langlaufende Berechnungsaufgaben
- Systeme, die tiefgehende Infrastrukturkontrolle benötigen
- Projekte mit komplexen, miteinander verbundenen Diensten

Serverless ist keine universelle Lösung, sondern ein spezialisierter Ansatz mit erheblichen Kompromissen.

### WebAssembly

WebAssembly (Wasm) ist ein binäres Instruktionsformat, das entwickelt wurde, um effizient in Webbrowsern ausgeführt zu werden. Es adressiert mehrere wichtige Herausforderungen in der Webentwicklung:

#### Warum WebAssembly?

#### Leistungssteigerung

- Wird mit nahezu nativer Geschwindigkeit ausgeführt, erheblich schneller als JavaScript
- Ermöglicht es, komplexe, leistungshungrige Anwendungen im Browser auszuführen

##### Sprachflexibilität

- Ermöglicht die Nutzung von Sprachen wie C, C++ und Rust für die Webentwicklung
- Entwickler können bestehende Codebasen und Fähigkeiten nutzen

##### Effizienz

- Kompaktes binäres Format für schnelleren Ladevorgang und Parsing
- Optimiert für moderne Hardwarefähigkeiten

##### Ergänzend zu JavaScript

- Arbeitet zusammen mit JavaScript, ersetzt es jedoch nicht
- Erweitert die Webfähigkeiten für rechenintensive Aufgaben

#### Wichtige Vorteile

1. **Hochleistungsfähige Webanwendungen**: Spiele, Videoverarbeitung und wissenschaftliche Simulationen
2. **Code-Wiederverwendung**: Bestehender C/C++/Rust-Code kann für das Web kompiliert werden
3. **Sichere Ausführung**: Läuft in einer isolierten Umgebung (Sandbox)
4. **Plattformübergreifende Kompatibilität**: Dasselbe Wasm-Modul läuft auf jedem kompatiblen Browser

WebAssembly eröffnet neue Möglichkeiten für Webanwendungen, indem es nahezu native Leistung in die Browser-Umgebung bringt und dabei Sicherheit und Kompatibilität mit bestehenden Webtechnologien beibehält.

### PWAs

Progressive Web Apps (PWAs) sind Webanwendungen, die die besten Eigenschaften traditioneller Websites und plattformspezifischer Apps kombinieren. Sie bieten eine native App-ähnliche Erfahrung, während sie mit standardisierten Webtechnologien wie HTML, CSS und JavaScript entwickelt werden.

#### Wichtige Merkmale von PWAs

##### Installierbarkeit

- Können auf Geräten wie native Apps installiert werden
- Erscheinen mit einem App-Icon auf dem Home-Bildschirm
- Starten als eigenständige Apps ohne Browser-Oberfläche

##### Leistung

- Schnelles Laden und eine reaktionsschnelle Benutzeroberfläche
- Funktionieren offline oder bei schlechten Netzwerkverbindungen
- Verwenden von Service Workern für Hintergrundverarbeitung und Caching

##### Plattformübergreifende Kompatibilität

- Laufen auf verschiedenen Betriebssystemen und Gerätetypen
- Einfache Codebasis für verschiedene Plattformen

##### Progressive Verbesserung

- Funktionieren auf grundlegenden Browsern und erweitern die Funktionen für moderne Browser
- Passen sich den verschiedenen Gerätefähigkeiten an

##### Sicherheit

- Werden über HTTPS bereitgestellt, um die Privatsphäre der Benutzer und die Authentizität der Inhalte zu gewährleisten

#### Technische Anforderungen

1. Sichere Herkunft (HTTPS)
2. Service Worker mit Fetch-Handler
3. Web-App-Manifest mit wesentlichen Eigenschaften

#### Vorteile

- Kostengünstigere Entwicklung im Vergleich zu nativen Apps
- Einfachere Wartung und Updates
- Von Suchmaschinen indexierbar
- Plattformunabhängig
- Zugänglich bei unterschiedlichen Netzwerkqualitäten
- Gestärkte Benutzerbindung durch "Installation"

PWAs stellen einen bedeutenden Wandel in der Entwicklung von Webanwendungen dar, indem sie eine Balance zwischen der Reichweite des Webs und der Erfahrung von nativen Anwendungen bieten.

### Lazy Loading

- oft leider wenig user Feedback vorhanden

#### Assets (iframe, img)

Lazy Loading funktioniert mittlerweile ohne Frameworks, dank der Unterstützung durch moderne Browser. Diese Funktionalität wird als **natives Lazy Loading** bezeichnet und kann direkt in HTML implementiert werden, indem man das `loading="lazy"` Attribut zu `<img>` und `<iframe>` Tags hinzufügt[1][2][3]. Diese Methode wird von den meisten gängigen Browsern wie Chrome, Firefox, Edge und Opera unterstützt[2]. Daher ist es nicht mehr notwendig, externe JavaScript-Bibliotheken oder Frameworks für die Implementierung von Lazy Loading zu verwenden[3].

#### Native JavaScript Module Lazy Loading

Lazy Loading für JavaScript-Code ist mittlerweile ohne zusätzliche Frameworks möglich, dank der nativen Unterstützung von ES6-Modulen in modernen Browsern.  
JavaScript unterstützt jetzt nativ das dynamische Importieren von Modulen, was Lazy Loading ohne zusätzliche Frameworks ermöglicht. Hier sind die Hauptpunkte:

1. **Dynamic Import**: Mit der `import()` Funktion können Module dynamisch geladen werden.

2. **Syntax**:

   ```javascript
   import("./module.js").then((module) => {
     // Verwende das Modul hier
   });
   ```

3. **Async/Await**: Kann auch mit async/await verwendet werden:

   ```javascript
   async function loadModule() {
     const module = await import("./module.js");
     // Verwende das Modul hier
   }
   ```

4. **Breite Unterstützung**: Diese Funktion wird von allen modernen Browsern unterstützt.

5. **Leistungsvorteile**: Ermöglicht das Laden von Code bei Bedarf, was die initiale Ladezeit der Anwendung verbessert.

Diese native Unterstützung macht es einfacher, Lazy Loading in JavaScript-Anwendungen zu implementieren, ohne auf externe Bibliotheken oder Frameworks angewiesen zu sein.

JavaScript Lazy Loading ist eine Technik, die darauf abzielt, die Lade- und Ausführungszeit von JavaScript-Dateien zu verzögern, bis sie tatsächlich benötigt werden. Dies verbessert die Ladegeschwindigkeit von Webseiten, da nur die notwendigen Ressourcen geladen werden, wenn der Nutzer sie benötigt[1][3].

##### Optionen für das Lazy Loading von JavaScript

###### **Intersection Observer API**

- **Funktionsweise**: Diese API erkennt, wann ein Element in den sichtbaren Bereich des Browsers eintritt oder diesen verlässt. Dadurch können JavaScript-Ressourcen nur dann geladen werden, wenn sie tatsächlich benötigt werden[1][4].
- **Implementierung**:

  ```javascript
  let observer = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        import("./module.js").then((module) => {
          // Modul verwenden
        });
      }
    });
  });

  observer.observe(document.querySelector("#targetElement"));
  ```

###### **Scroll-Event**

- **Funktionsweise**: JavaScript wird geladen, wenn der Nutzer zu einem bestimmten Abschnitt der Seite scrollt. Dies ist besonders nützlich für Inhalte, die nicht sofort sichtbar sind[1].
- **Implementierung**:
  ```javascript
  window.addEventListener("scroll", () => {
    if (
      document.querySelector("#targetElement").getBoundingClientRect().top <
      window.innerHeight
    ) {
      import("./module.js").then((module) => {
        // Modul verwenden
      });
    }
  });
  ```

##### **Vanilla LazyLoad Script**

- **Beschreibung**: Ein leichtgewichtiges Script, das das Laden von Bildern, Videos und anderen Inhalten verzögert, bis sie in den sichtbaren Bereich kommen[2].
- **Verwendung**:
  ```javascript
  var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy",
  });
  ```

##### **Vorteile von Lazy Loading**

- **Verbesserte Ladezeiten**: Reduziert die anfängliche Ladezeit der Seite und verbessert die Benutzererfahrung.
- **Bandbreiteneinsparung**: Spart Datenverkehr und Rechenleistung, indem nur benötigte Ressourcen geladen werden[3][4].

Durch die Implementierung dieser Techniken kann die Performance von Webseiten erheblich verbessert werden, besonders bei umfangreichen Anwendungen mit vielen Ressourcen.

#### Script-Attribute für Lazy Loading

##### async und defer

- **async**: Lädt das Script asynchron und führt es aus, sobald es verfügbar ist.
- **defer**: Lädt das Script asynchron, führt es aber erst aus, wenn das HTML-Parsing abgeschlossen ist.

Beispiel:

```html
<script src="script.js" async></script>
<script src="script.js" defer></script>
```

##### type="module"

- Kennzeichnet ein Script als ES6-Modul.
- Module werden standardmäßig verzögert geladen.

Beispiel:

```html
<script type="module" src="module.js"></script>
```

##### data-src

- Wird häufig für benutzerdefiniertes Lazy Loading verwendet.
- Das Script wird nicht sofort geladen, sondern erst wenn es benötigt wird.

Beispiel:

```html
<script data-src="lazy-script.js"></script>
```

##### Kombination mit template-Element

Eine fortgeschrittene Technik verwendet das `<template>`-Element, um Scripts zu verzögern:

```html
<template id="lazy-scripts">
  <script src="async.js" async></script>
  <script src="deferred.js"></script>
</template>
```

Diese Methode erlaubt es, die Scripts im DOM zu platzieren, ohne dass sie sofort geladen oder ausgeführt werden[1].

Die Verwendung dieser Attribute ermöglicht eine feinere Kontrolle über das Laden und Ausführen von JavaScript, was zu verbesserten Ladezeiten und einer optimierten Webseitenperformance führen kann.

## Frontend is hard

"Frontend is hard" ist ein oft gehörter Ausspruch in der Webentwicklung, der die Komplexität und die Herausforderungen der Frontend-Entwicklung widerspiegelt. Hier sind einige Gründe, warum Frontend-Entwicklung als schwierig angesehen wird:

### Gründe für die Komplexität des Frontends

#### 1. Ständiger technologischer Wandel

- Neue Frameworks und Bibliotheken erscheinen regelmäßig
- Entwickler müssen sich kontinuierlich weiterbilden, um auf dem Laufenden zu bleiben

#### 2. Browser-Kompatibilität

- Unterschiedliche Browser interpretieren Code unterschiedlich
- Notwendigkeit, Websites für verschiedene Browser und Versionen zu optimieren

#### 3. Responsive Design

- Herausforderung, Websites für verschiedene Bildschirmgrößen und Geräte zu optimieren
- Komplexe Layouts müssen auf allen Geräten funktionieren

#### 4. Performance-Optimierung

- Balanceakt zwischen Funktionalität und Ladegeschwindigkeit
- Optimierung von Bildern, Skripten und Stylesheets für schnelle Ladezeiten

#### 5. Benutzerfreundlichkeit und Zugänglichkeit

- Gestaltung intuitiver und inklusiver Benutzeroberflächen
- Berücksichtigung von Barrierefreiheit für alle Nutzergruppen

#### 6. JavaScript-Komplexität

- Asynchrone Programmierung und Zustandsmanagement
- Komplexe Interaktionen und Animationen

#### 7. Sicherheit

- Schutz vor Cross-Site Scripting (XSS) und anderen Frontend-Sicherheitsrisiken
- Implementierung sicherer Authentifizierungsmethoden

#### 8. Testing und Debugging

- Herausforderungen beim Testen von UI-Komponenten und Benutzerinteraktionen
- Komplexität des Debuggings in verschiedenen Umgebungen

Die Kombination dieser Faktoren macht Frontend-Entwicklung zu einer anspruchsvollen Disziplin, die sowohl technisches Wissen als auch kreative Problemlösungsfähigkeiten erfordert.

### Responsive Design

Responsive Webdesign (RWD) ist ein Ansatz zur Gestaltung von Websites, der darauf abzielt, dass Webseiten auf einer Vielzahl von Geräten und Bildschirmgrößen gut dargestellt werden. Hier sind einige zentrale Aspekte des Responsive Designs:

#### Grundlagen des Responsive Webdesigns

##### Definition

- **Responsive Webdesign** bedeutet, dass sich das Layout einer Webseite an die Umgebung anpasst, in der sie betrachtet wird. Dies umfasst Bildschirmgröße, Plattform und Ausrichtung des Geräts[1][5].

##### Techniken

- **Fluid Grids**: Elemente werden in relativen Einheiten wie Prozent anstatt in festen Einheiten wie Pixeln gestaltet[5].
- **Flexible Bilder**: Bilder passen sich der Größe ihres umgebenden Containers an, um das Layout nicht zu sprengen[5].
- **Media Queries**: CSS3 Media Queries ermöglichen es, verschiedene CSS-Regeln basierend auf den Eigenschaften des Geräts anzuwenden, z.B. Bildschirmbreite oder -höhe[2][3].

#### Vorteile und Herausforderungen

##### Vorteile

- **Benutzerfreundlichkeit**: Eine responsive Webseite bietet eine konsistente Benutzererfahrung auf allen Geräten, was die Usability verbessert[2][5].
- **SEO-Vorteile**: Google bevorzugt mobile-freundliche Webseiten in den Suchergebnissen, was zu einer besseren Sichtbarkeit führen kann[5].

##### Herausforderungen

- **Komplexität**: Die Entwicklung eines responsiven Designs kann komplex sein, da es erfordert, dass Inhalte und Layouts flexibel gestaltet werden[2][5].
- **Performance**: Die Anpassung von Bildern und anderen Medien für verschiedene Geräte kann die Ladezeiten beeinflussen[1].

#### Implementierung

##### HTML5 und CSS3

- Responsive Designs werden hauptsächlich mit HTML5 und CSS3 realisiert. Media Queries sind ein zentrales Werkzeug, um das Layout dynamisch an verschiedene Geräte anzupassen[2][4].

###### Beispiele für CSS Media Queries

```css
@media all and (max-width: 600px) {
  .example-class {
    font-size: 14px;
  }
}
```

###### Responsive Images

- Die Verwendung von `max-width: 100%` in CSS sorgt dafür, dass Bilder innerhalb ihres Containers skalieren und nicht größer als ihre Originalgröße angezeigt werden[1][4].

Responsive Webdesign ist ein wesentlicher Bestandteil moderner Webentwicklung und stellt sicher, dass Webseiten auf allen Geräten optimal funktionieren und gut aussehen.

## Webtechnologien- und Standards

### Webtechnologien: HTML5, CSS3, ES6 und Standards

Webtechnologien wie HTML5, CSS3 und ES6 sind grundlegende Bausteine der modernen Webentwicklung. Sie werden von verschiedenen Organisationen standardisiert und kontinuierlich weiterentwickelt, um den Anforderungen an moderne Webanwendungen gerecht zu werden.

#### HTML5

**Definition und Zweck**: HTML5 ist die fünfte Version der Hypertext Markup Language. Es wird verwendet, um die Struktur und das Layout von Webseiten zu definieren. HTML5 bringt neue Elemente wie `<video>`, `<audio>`, und `<canvas>` mit, die die Integration von Multimedia-Inhalten erleichtern[1].

**Standardisierung**: HTML5 wird vom World Wide Web Consortium (W3C) und der Web Hypertext Application Technology Working Group (WHATWG) standardisiert. Diese Organisationen arbeiten zusammen, um die Spezifikationen zu entwickeln und zu pflegen.

#### CSS3

**Definition und Zweck**: CSS3 ist die neueste Version der Cascading Style Sheets und wird verwendet, um das Aussehen von Webseiten zu gestalten. CSS3 führt neue Stilregeln ein, einschließlich Animationen, Flexbox, Grid Layouts und Media Queries für responsives Design[4].

**Standardisierung**: CSS3 wird ebenfalls vom W3C standardisiert. Die Spezifikationen werden in Modulen veröffentlicht, die unabhängig voneinander entwickelt werden können.

#### ES6 (ECMAScript 2015)

**Definition und Zweck**: ES6 ist die sechste Version des ECMAScript-Standards, der JavaScript zugrunde liegt. Es bietet zahlreiche neue Funktionen wie Klassen, Module, Promises, Arrow Functions und Template Literals[1][2][3].

**Standardisierung**: Der ECMAScript-Standard wird von Ecma International gepflegt. Jährliche Updates stellen sicher, dass JavaScript mit den neuesten Entwicklungen in der Programmierung Schritt hält.

#### Standards

Diese Technologien basieren auf offenen Standards, die von internationalen Gremien entwickelt werden. Die Standardisierung gewährleistet:

- **Interoperabilität**: Konsistentes Verhalten über verschiedene Browser hinweg
- **Zukunftssicherheit**: Regelmäßige Updates und Verbesserungen
- **Zugänglichkeit**: Unterstützung für Entwickler weltweit durch umfassende Dokumentation

Durch diese Standards können Entwickler sichere, effiziente und plattformübergreifende Anwendungen erstellen. Die kontinuierliche Weiterentwicklung dieser Technologien ermöglicht es dem Web, sich an neue Herausforderungen anzupassen und innovative Lösungen zu bieten.

##### Implementierung neuer Webstandards in Browsern

Die Implementierung neuer HTML-, CSS- und JavaScript-Features in Browsern ist ein komplexer Prozess, der mehrere Phasen durchläuft:

###### Vorschlag und Diskussion

- Neue Features werden oft von Browserherstellern, Entwicklern oder Standardisierungsorganisationen vorgeschlagen.
- Chrome schlägt aktiv neue Features vor, die dann in öffentlichen Foren diskutiert werden[1][3].

###### Standardisierungsprozess

1. **Explainer**: Ein Dokument, das Use Cases und Szenarien für das neue Feature beschreibt[4].
2. **Prototyping**: Implementierung eines Prototyps hinter einem Flag im Browser[4].
3. **Spezifikation**: Ausarbeitung einer detaillierten Spezifikation, oft in Zusammenarbeit mit W3C-Arbeitsgruppen[3].

###### Implementierung und Testing

- Features werden zunächst hinter Flags implementiert[3].
- Chrome nutzt "Origin Trials", um Features mit einer begrenzten Nutzergruppe zu testen[3].
- Entwickler können Feedback geben und Bugs melden[3].

###### Stufenweise Einführung

- Viele Features werden schrittweise eingeführt, um potenzielle Probleme zu überwachen[3].
- Beispiel: Die Reduzierung des User-Agent-Strings in Chrome wurde über mehrere Monate hinweg implementiert[3].

###### Vollständige Implementierung

- Nach erfolgreichen Tests wird das Feature standardmäßig in den Browser integriert[3].
- Die Dokumentation wird aktualisiert und das Feature für die breite Nutzung freigegeben[3].

Chrome spielt eine aktive Rolle in diesem Prozess, indem es nicht nur Features implementiert, sondern auch neue Vorschläge einbringt und den gesamten Lebenszyklus von der Idee bis zur vollständigen Implementierung begleitet[1][3][4].

## Technische Standards

### Was ist RFC?

RFC steht für **Request for Comments** und ist ein Dokument, das technische Spezifikationen, Standards und Protokolle im Bereich der Internet-Technologien beschreibt. Diese Dokumente sind Teil des Standardisierungsprozesses, der von der Internet Engineering Task Force (IETF) und anderen Organisationen durchgeführt wird.

#### Merkmale von RFCs

- **Technische Dokumentation**: RFCs decken eine Vielzahl von Themen ab, darunter Netzwerkprotokolle, Formate, Verfahren und Best Practices.
- **Offener Prozess**: Jeder kann RFCs vorschlagen oder kommentieren, was zu einem offenen Diskussionsprozess führt.
- **Nummerierungssystem**: Jedes RFC erhält eine eindeutige Nummer, die es einfach macht, auf spezifische Dokumente zu verweisen.

#### Beispiele für wichtige RFCs

- **RFC 791**: Definiert das Internet Protocol (IP).
- **RFC 2616**: Beschreibt das Hypertext Transfer Protocol (HTTP/1.1).

#### Standardisierung

Die IETF ist die Hauptorganisation, die für die Entwicklung und Pflege von RFCs verantwortlich ist. Sie arbeitet eng mit anderen Organisationen wie dem World Wide Web Consortium (W3C) zusammen, um sicherzustellen, dass die Standards interoperabel sind.

#### Fazit

RFCs sind entscheidend für die Entwicklung und Standardisierung von Internet-Technologien. Sie bieten eine strukturierte Möglichkeit, technische Informationen zu dokumentieren und zu verbreiten, und fördern die Zusammenarbeit innerhalb der Entwicklergemeinschaft.

## Quellen

### 1. - allgemeine Geschichte

[1] https://stachowitz-medien.de/die-8-phasen-einer-webseite/
[2] https://www.tenmedia.de/de/glossar/webentwicklung
[3] https://academy.technikum-wien.at/ratgeber/web-development/
[4] https://intexsoft.com/de/blog/webentwicklung/
[5] https://de.wikipedia.org/wiki/Webentwicklung
[6] https://wiki.selfhtml.org/wiki/HTML/Tutorials/Entstehung_und_Entwicklung
[7] https://de.webmasters-europe.org/berufsprofile/web-entwickler-web-developer
[8] https://journals.univie.ac.at/index.php/mz/article/download/8142/8192/22607

### 2. - Browser

[1] https://www.domradio.de/artikel/vorlaeufer-von-mozilla-chrome-oder-safari-vor-30-jahren-wurde-der-erste-webbrowser
[2] https://de.wikipedia.org/wiki/Browser
[3] https://www.netplanet.org/www/browser.shtml
[4] https://www.eco.de/verbandsnews/der-erste-web-browser/
[5] https://de.wikipedia.org/wiki/WorldWideWeb
[6] https://vsr.informatik.tu-chemnitz.de/proseminare/www03/doku/browser/geschichte.htm
[7] https://intexsoft.com/de/blog/webentwicklung/
[8] https://de.wikipedia.org/wiki/Webentwicklung
[9] https://de.wikipedia.org/wiki/WorldWideWeb
[10] https://digital-archaeology.org/the-nexus-browser/
[11] https://en.wikipedia.org/wiki/WorldWideWeb
[13] https://www.webdesignmuseum.org/web-design-history/worldwideweb-the-first-browser-1990
[14] https://www.w3.org/People/Berners-Lee/WorldWideWeb.html
[15] https://worldwideweb.cern.ch/history/
[16] https://www.meetsidekick.com/who-created-the-first-web-browser/
[17] https://www.youtube.com/watch?v=3c3Rt6QbHDw

#### 2.1. Browser-Monopol: Chrome

[1] https://netzpolitik.org/2024/us-justizministerium-google-soll-chrome-verkaufen-um-suchmonopol-zu-brechen/
[2] https://www.focus.de/panorama/welt/monopol-vorwurf-us-regierung-strebt-verkauf-von-googles-chrome-browser-an_id_260498182.html
[3] https://www.tagesspiegel.de/gesellschaft/medien/monopol-vorwurf-us-regierung-google-muss-chrome-browser-verkaufen-12743270.html
[4] https://www.stern.de/digital/monopol-vorwurf--us-regierung--google-muss-chrome-browser-verkaufen-35245986.html
[5] https://www.bbc.com/news/articles/cp81ppr3l9go
[6] https://www.zdf.de/nachrichten/wirtschaft/unternehmen/chrome-google-trennung-us-gericht-monopol-100.html
[7] https://www.euronews.com/next/2024/11/21/google-should-sell-its-chrome-browser-to-stop-its-search-monopoly-us-regulators-say
[8] https://www.theregister.com/2024/11/23/opinion_google_chrome/
[9] https://de.wikipedia.org/wiki/Browser
[10] https://www.netplanet.org/www/browser.shtml
[11] https://vsr.informatik.tu-chemnitz.de/proseminare/www03/doku/browser/geschichte.htm

##### Statistiken

- https://gs.statcounter.com
- https://gs.statcounter.com/browser-market-share/mobile/worldwide
- https://gs.statcounter.com/browser-market-share/desktop/worldwide
- https://gs.statcounter.com/browser-market-share/tablet/worldwide

### 3. - Suchmaschinen

[1] https://www.techbook.de/connectivity/suchmaschinen-geschichte
[2] https://www.lmn1.de/die-geschichte-und-entstehung-der-suchmaschinen/
[3] https://blog.wiwo.de/look-at-it/2015/03/06/25-jahre-internet-suchmaschinen-von-archie-uber-altavista-und-google-bis-cortana/
[4] https://www.hanseranking.de/die-geschichte-der-suchmaschinen/
[5] https://www.heise-regioconcept.de/google/vorgaenger-von-google-und-alternative-suchmaschinen
[6] https://de.wikipedia.org/wiki/AltaVista
[7] https://www.spiegel.de/netzwelt/web/suchmaschinen-vor-google-am-anfang-war-die-liste-a-577644.html
[8] https://futurezone.at/digital-life/erste-suchmaschine-internet-archie-ftp-geschichte-the-serial-port-alan-emtage/402900380
[9] https://www.mcgill.ca/about/history
[10] https://200.mcgill.ca/history/creation-of-the-first-internet-search-engine/
[11] https://mcgillnews.mcgill.ca/search-engine-pioneer-inducted-into-internet-hall-of-fame/
[12] https://historyofdomainnames.com/archie-the-history-of-domain-names/
[13] https://en.wikipedia.org/wiki/Archie_(search_engine)
[14] https://www.mcgill.ca/architecture/
[15] https://worldwideweb.cern.ch/history/
[16] https://en.wikipedia.org/wiki/WorldWideWeb

### Lazy Loading

[1] https://www.ionos.at/digitalguide/websites/webseiten-erstellen/lazy-loading/
[2] https://www.massiveart.com/en/blog/natives-lazy-loading-performance-steigerung-ohne-externe-libraries
[3] https://wpwissen.com/lazy-loading-ohne-javascript/
[4] https://www.cloudflare.com/de-de/learning/performance/what-is-lazy-loading/
[5] https://www.splendid-internet.de/blog/lazy-loading-pagespeed-pflichtprogramm-fuer-onlineshops/
[6] https://fastwp.de/lazy-load-fur-videos-ohne-plugin/
[7] https://de.ryte.com/wiki/Lazy_Load
[8] https://web.dev/articles/browser-level-image-lazy-loading

[1] https://nitropack.io/blog/post/javascript-lazy-loading
[2] https://github.com/verlok/vanilla-lazyload
[3] https://www.cloudflare.com/de-de/learning/performance/what-is-lazy-loading/
[4] https://developer.mozilla.org/en-US/docs/Web/Performance/Lazy_loading
[5] https://imagekit.io/blog/lazy-loading-images-complete-guide/
[6] https://www.cloudflare.com/learning/performance/what-is-lazy-loading/
[7] https://blog.openreplay.com/lazy-loading-in-javascript/
[8] https://blog.logrocket.com/understanding-lazy-loading-javascript/

[1] https://gist.github.com/LionsAd/d6d490161e5d07bfa6d14cd711bc528e
[2] https://nitropack.io/blog/post/javascript-lazy-loading
[3] https://imagekit.io/blog/lazy-loading-images-complete-guide/
[4] https://github.com/verlok/vanilla-lazyload
[5] https://stackoverflow.com/questions/67487446/lazy-load-a-javascript-script
[6] https://blog.openreplay.com/lazy-loading-in-javascript/
[7] https://developer.mozilla.org/en-US/docs/Web/Performance/Lazy_loading
[8] https://blog.logrocket.com/understanding-lazy-loading-javascript/

### Responsive Design

[1] https://www.smashingmagazine.com/2011/01/guidelines-for-responsive-web-design/
[2] https://en.ryte.com/wiki/Responsive_Design
[3] https://www.w3schools.com/css/css_rwd_intro.asp
[4] https://www.w3schools.com/html/html_responsive.asp
[5] https://en.wikipedia.org/wiki/Responsive_web_design
[6] https://de.wikipedia.org/wiki/Responsive_Webdesign
[7] https://blog.hubspot.de/website/responsive-design
[8] https://www.ionos.at/digitalguide/websites/webdesign/was-bedeutet-responsive-design/

### Typescript

[1] https://www.clickittech.com/developer/why-use-typescript/
[2] https://prismic.io/blog/what-is-typescript
[3] https://www.reddit.com/r/typescript/comments/1avfm4r/why_should_we_use_typescript_over_javascript/
[4] https://stackoverflow.com/questions/12694530/what-is-typescript-and-why-should-i-use-it-instead-of-javascript/35048303
[5] https://www.contentful.com/blog/what-is-typescript-and-why-should-you-use-it/
[6] https://www.typescriptlang.org/why-create-typescript/
[7] https://blog.openreplay.com/lazy-loading-in-javascript/
[8] https://nitropack.io/blog/post/javascript-lazy-loading

#### Javascript

[1] https://buttondown.com/hillelwayne/archive/did-brendan-eich-really-make-javascript-in-10-days/
[2] https://www.reddit.com/r/programming/comments/16v7zv2/was_javascript_really_made_in_10_days/
[3] https://en.wikipedia.org/wiki/JavaScript
[4] https://stackoverflow.com/questions/12694530/what-is-typescript-and-why-should-i-use-it-instead-of-javascript/35048303
[5] https://softteco.com/blog/history-of-javascript
[6] https://learnreactui.dev/contents/the-development-of-javascript-through-time
[7] https://maybe.works/blogs/javascript-history-why-does-it-so-popular-for-web-development
[8] https://www.contentful.com/blog/what-is-typescript-and-why-should-you-use-it/

### Serverless

[1] https://completecoding.io/avoid-serverless-pitfalls/
[2] https://duplocloud.com/the-dark-side-of-serverless-computing-performance-debugging-and-scalability-issues/
[3] https://www.serverless.direct/post/serverless-implementation-issues
[4] https://brainhub.eu/library/disadvantages-of-serverless-computing
[5] https://sysdig.com/learn-cloud-native/serverless-security-risks-and-best-practices/
[6] https://builtin.com/articles/serverless-architecture-challenges
[7] https://devops.com/5-serverless-challenges-of-devops-teams-and-how-to-overcome-them/
[8] https://logz.io/blog/pitfalls-of-serverless/

### WebAssembly

[1] https://www.techtarget.com/searchitoperations/definition/WebAssembly
[2] https://www.spiceworks.com/tech/devops/articles/what-is-webassembly/
[3] https://developer.mozilla.org/en-US/docs/WebAssembly/Concepts
[4] https://developer.mozilla.org/en-US/docs/WebAssembly
[5] https://www.reddit.com/r/webdev/comments/thgkw7/can_you_explain_webassembly/
[6] https://en.wikipedia.org/wiki/WebAssembly
[7] https://www.jakobmeier.ch/wasm-road-0
[8] https://en.wikipedia.org/wiki/JavaScript

### PWAs

[1] https://web.dev/explore/progressive-web-apps
[2] https://de.wikipedia.org/wiki/Progressive_Web_App
[3] https://www.conductor.com/academy/glossary/progressive-web-apps/
[4] https://en.wikipedia.org/wiki/Progressive_web_app
[5] https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Guides/What_is_a_progressive_web_app
[6] https://web.dev/learn/pwa/progressive-web-apps
[7] https://www.ionos.at/digitalguide/websites/web-entwicklung/progressive-web-apps-welche-vorteile-bieten-sie/
[8] https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps

### Webtechnologien- und Standards

[1] https://stackshare.io/stackups/es6-vs-html5
[2] https://caniuse.com/?search=es6
[3] https://www.w3schools.com/js/js_es6.asp
[4] https://www.protechtraining.com/modern-web-development-with-html5-css3-modern-javascript-es6-pt24482
[5] https://en.wikipedia.org/wiki/Progressive_web_app
[6] https://vuejs.org/guide/built-ins/transition
[7] https://blog.q-bit.me/lets-build-vue-directives-motion-design-with-vmotion/
[8] https://vuejs.org/guide/reusability/custom-directives

### Implementierung neuer Webstandards in Browsern

[1] https://developers.google.com/privacy-sandbox/overview/status
[2] https://support.google.com/google-ads/answer/11899856?hl=en
[3] https://developers.google.com/privacy-sandbox/overview/proposal-lifecycle
[4] https://www.chromium.org/blink/launching-features/
[5] https://developer.chrome.com/docs/extensions/support/request-feature
[6] https://github.com/GoogleChrome/chromium-dashboard/issues/4465
[7] https://chromewebstore.google.com/detail/generate-proposal/okbaokbebkidmjhpcdbhdbdgchemfooc
[8] https://stackshare.io/stackups/es6-vs-html5

## Technische Standards

[1] https://en.wikipedia.org/wiki/Radio_frequency
[2] https://www.rfglobalsolutions.co.uk/what-is-radio-frequency-rf/
[3] https://www.techtarget.com/searchnetworking/definition/radio-frequency
[4] https://www.crfs.com/making-sense-of-radio-frequency
[5] https://www.fcc.gov/engineering-technology/electromagnetic-compatibility-division/radio-frequency-safety/faq/rf-safety
[6] https://de.wikipedia.org/wiki/Hochfrequenz
[7] https://www.rohde-schwarz.com/fi/products/test-and-measurement/essentials-test-equipment/spectrum-analyzers/what-is-rf-radio-frequency-technologies-_256007.html
[8] https://mncomputinghistory.com/gopher-protocol/
